---

title: Mysql高级-02 SQL语句的执行顺序
date: 2020-02-28  22:36:26
tags: 
    - Mysql
    - CentOS
---

### 1.手写`SQL`

```sql
select distinct
     <select_list>
from
     <left_table> <join_type>
join <right_table> on <join_condition>
where 
     <where_condition>
group by
     <group_by_list>
having
     <having_confition>
order by
     <order_by_condition>
limit <limit_number>
```

<!--more-->

### 2.机读顺序

#### 2.1文字表示

```sql
1.from <left_table>
2.on <join_condition>
3.<join_type>join <right_table> 
4.where <where_condition>
5.group by<group_by_list>
6.having<having_confition>
7.select
8.distinct<select_list>
9.order by<order_by_condition>
10.limit <limit_number>
```

#### 2.2 图形表示

![](/image/mysql/image-20200229224750440.png)



### 3.总结归纳

- **FROM**:对左右两张表执行笛卡尔积，产生第一张表vt1。行数为n*m（n为左表的行数，m为右表的行数）
- **ON**:根据ON的条件逐行筛选vt1，将结果插入vt2中
- **JOIN**:添加外部行，如果指定了**LEFT JOIN(LEFT OUTER JOIN\)**，则先遍历一遍左表的每一行，其中不在vt2的行会被插入到vt2，该行的剩余字段将被填充为**NULL**，形成vt3；如果指定了**RIGHT JOIN**也是同理。但如果指定的是**INNER JOIN**，则不会添加外部行，上述插入过程被忽略，vt2=vt3（所以**INNER JOIN**的过滤条件放在**ON**或**WHERE**里 执行结果是没有区别的，下文会细说）
- **WHERE**:对vt3进行条件过滤，满足条件的行被输出到vt4
- **GROUP BY**：对vt4进行分组放进vt5中
- **HAVING**:对vt5中的结果进行条件筛选，满足条件的行被输出到vt6中
- **SELECT**:取出vt6的指定字段到vt7
- **DISTINCT**：将vt7中的重复项去掉并放到vt8中
- **ORDER BY**：对vt8中的结果进行排序放进vt9中
- **LIMIT**：从vt9中筛选出符合条件的结果放入vt10

### 4.举例说明

创建一个用户信息表：

```
CREATE TABLE `user_info` (
  `userid` int(11) NOT NULL,
  `name` varchar(255) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

再创建一个用户账号表：

```
CREATE TABLE `user_account` (
  `userid` int(11) NOT NULL,
  `accountId` varchar(255) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

向用户信息表中插入数据：

```
+--------+--------+
| userid | name   |
+--------+--------+
|      1 | 张三   |
|      2 | 李四   |
|      3 | 王五   |
|      4 | 赵六   |
+--------+--------+
```

向用户账号账号表中插入数据：

```
+--------+-------------------+
| userid | accountId         |
+--------+-------------------+
|      1 | 98615412089946112 |
|      1 | 98615412089946113 |
|      1 | 98615412089946114 |
|      1 | 98615412089946115 |
|      5 | 98615412089946116 |
|      2 | 98615412089946117 |
|      2 | 98615412089946118 |
|      3 | 98615412089946119 |
+--------+-------------------+
```



找出userid小于4，账号个数大于等于2且账号个数排在第二名的名字。

```
select user_info.name
from user_info
         left join user_account ua
                   on ua.userid = user_info.userid
where ua.userid < 4
group by name
having count(name) >= 2
order by  count(name) desc
limit 1,1;
```

#### 4.1 第一步：执行FROM子句对两张表进行笛卡尔积操作

笛卡尔积操作后会返回两张表中所有行的组合，左表user_info有4行，右表user_account有8行，生成的虚拟表vt1就是4*8=32行：

```sql
 select  * from user_info left join user_account ua on 1;
+--------+--------+--------+-------------------+
| userid | name   | userid | accountId         |
+--------+--------+--------+-------------------+
|      1 | 张三   |      1 | 98615412089946112 |
|      2 | 李四   |      1 | 98615412089946112|
|      3 | 王五   |      1 | 98615412089946112|
|      4 | 赵六   |      1 | 98615412089946112|
|      1 | 张三   |      1 | 98615412089946113 |
|      2 | 李四   |      1 | 98615412089946113 |
|      3 | 王五   |      1 | 98615412089946113 |
|      4 | 赵六   |      1 | 98615412089946113 |
|      1 | 张三   |      1 | 98615412089946114 |
|      2 | 李四   |      1 | 98615412089946114 |
|      3 | 王五   |      1 | 98615412089946114 |
|      4 | 赵六   |      1 | 98615412089946114 |
|      1 | 张三   |      1 | 98615412089946115 |
|      2 | 李四   |      1 | 98615412089946115 |
|      3 | 王五   |      1 | 98615412089946115 |
|      4 | 赵六   |      1 | 98615412089946115 |
|      1 | 张三   |      5 | 98615412089946116 |
|      2 | 李四   |      5 | 98615412089946116 |
|      3 | 王五   |      5 | 98615412089946116 |
|      4 | 赵六   |      5 | 98615412089946116 |
|      1 | 张三   |      2 | 98615412089946117 |
|      2 | 李四   |      2 | 98615412089946117 |
|      3 | 王五   |      2 | 98615412089946117 |
|      4 | 赵六   |      2 | 98615412089946117 |
|      1 | 张三   |      2 | 98615412089946118 |
|      2 | 李四   |      2 | 98615412089946118 |
|      3 | 王五   |      2 | 98615412089946118 |
|      4 | 赵六   |      2 | 98615412089946118 |
|      1 | 张三   |      3 | 98615412089946119 |
|      2 | 李四   |      3 | 98615412089946119 |
|      3 | 王五   |      3 | 98615412089946119 |
|      4 | 赵六   |      3 | 98615412089946119 |
+--------+--------+--------+-------------------+
32 rows in set (0.00 sec)


```

#### 4.2 第二步：执行ON子句过滤掉不满足条件的行

on ua.userid = user_info.userid 过滤之后vt2如下：

```

mysql> select  * from user_info left join user_account ua on ua.userid=user_info.userid;
+--------+--------+--------+-------------------+
| userid | name   | userid | accountId         |
+--------+--------+--------+-------------------+
|      1 | 张三   |      1 | 98615412089946112 |
|      1 | 张三   |      1 | 98615412089946113 |
|      1 | 张三   |      1 | 98615412089946114 |
|      1 | 张三   |      1 | 98615412089946115 |
|      2 | 李四   |      2 | 98615412089946117 |
|      2 | 李四   |      2 | 98615412089946118 |
|      3 | 王五   |      3 | 98615412089946119 |
+--------+--------+--------+-------------------+
```

#### 4.3 第三步：JOIN 添加外部行

**LEFT JOIN**会将左表未出现在vt2的行插入进vt2，每一行的剩余字段将被填充为NULL，**RIGHT JOIN**同理
本例中用的是**LEFT JOIN**，所以会将左表user_account剩下的行都添上生成表vt3：

```
mysql> select  * from user_info left join user_account ua on ua.userid=user_info.userid;
+--------+--------+--------+-------------------+
| userid | name   | userid | accountId         |
+--------+--------+--------+-------------------+
|      1 | 张三   |      1 | 98615412089946112 |
|      1 | 张三   |      1 | 98615412089946113 |
|      1 | 张三   |      1 | 98615412089946114 |
|      1 | 张三   |      1 | 98615412089946115 |
|      2 | 李四   |      2 | 98615412089946117 |
|      2 | 李四   |      2 | 98615412089946118 |
|      3 | 王五   |      3 | 98615412089946119 |
|      4 | 赵六   |   NULL | NULL              |
+--------+--------+--------+-------------------+
```

#### 4.4 第四步：WHERE条件过滤

where ua.userid < 4

```
+--------+--------+--------+-------------------+
| userid | name   | userid | accountId         |
+--------+--------+--------+-------------------+
|      1 | 张三   |      1 | 98615412089946115 |
|      1 | 张三   |      1 | 98615412089946114 |
|      1 | 张三   |      1 | 98615412089946113 |
|      1 | 张三   |      1 | 98615412089946113 |
|      2 | 李四   |      2 | 98615412089946118 |
|      2 | 李四   |      2 | 98615412089946117 |
|      3 | 王五   |      3 | 98615412089946119 |
+--------+--------+--------+-------------------+
```

#### 4.5 第五步：GROUP BY 分组

group by name

```
+--------+---+
| name   | a |
+--------+---+
| 张三   | 4 |
| 李四   | 2 |
| 王五   | 1 |
+--------+---+
```

#### 4.6 第六步：通过HAVING过滤符合条件的

having count(name) >= 2

```
+--------+---+
| name   | a |
+--------+---+
| 张三   | 4 |
| 李四   | 2 |
+--------+---+
```

#### 4.7 第七步：SELECT 

```
+--------+
| name   |
+--------+
| 张三   |
| 李四   |
+--------+
```

#### 4.8  第八步：ORDER BY

order by  count(name) desc

```
+--------+
| name   |
+--------+
| 张三   |
| 李四   |
+--------+
```

#### 4.9 第九步：LIMIT 

limit 1,1;

```
+--------+
| name   |
+--------+
| 李四   |
+--------+
```



### 666.彩蛋

请大家持续关注公众号：Java橙序猿

 ![](/image/common/superdevops.jpg) 

关注博客：

```
 http://superdevops.cn
```
